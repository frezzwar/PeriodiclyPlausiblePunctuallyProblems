Package     Grammar;

Helpers
    digit           = ['0' .. '9'];
    nonzero_digit   = ['1' .. '9'];
    letter          = ['a' .. 'z'] + ['A' .. 'Z'];
    tab             = 9;
    lf              = 10;
    cr              = 13; 
    dot             = '.';  
    decimal_test    = 0 | nonzero_digit digit*;

Tokens
    underscore      = '_';
    plus            = '+';
    minus           = '-';
    mult            = '*';
    div             = '/';
    equals          = '=';
    par_l           = '(';
    par_r           = ')';
    curly_l         = '{';
    curly_r         = '}';
    brack_l         = '[';
    brack_r         = ']';
    quote           = '"';
    comma           = ',';
    colon           = ':';
    repeat          = 'repeat';
    new             = 'new';
    while           = 'while';
    if              = 'if';
    else            = 'else';
    create          = 'create';
    semi_c          = ';';
    x               = 'x';
    y               = 'y';
    fig             = 'fig';
    size            = 'size';
    percentage      = '%';
    blank           = (' ' | tab | lf | cr)*;
    foreach         = 'foreach';
    in              = 'in';
    startup         = 'startup';
    click           = 'click';
    key_press       = 'key_press';
    testevent       = 'testevent';
    touch           = 'touch';
    edge            = 'edge';
    add             = 'add';
    dist            = 'dist';
    random          = 'random';
    set             = 'set';
    change          = 'change';
    turn_left       = 'turnLeft';
    turn_right      = 'turnRight';
    walk            = 'walk';
    turnto          = 'turnto';
    slide           = 'slide';
    wait            = 'wait';
    wait_until      = 'wait_until';
    say             = 'say';
    think           = 'think';
    hide            = 'hide';
    show            = 'show';
    layer           = 'layer';
    ask             = 'ask';
    deg             = 'deg';
    steps           = 'steps';
    sec             = 'sec';
    true            = 'true';
    false           = 'false';
    dot             = '.';
    rnd             = 'rnd';
    to              = 'to';

    equal           = '==';
    less_equal      = '<=';
    greater_equal   = '>=';
    negate          = '!=';
    and             = '&&';
    or              = '||';

    string          = '"' (letter | digit)+ '"';
    floatliteral    = digit* dot digit+;
    decimal         = decimal_test;
    stringliteral   = letter*;

    input_key        = letter 
                    | digit
                    | 'up'
                    | 'down'
                    | 'left'
                    | 'right'
                    | 'space';
                     
    id              = letter*;

Ignored Tokens
    blank;

Productions
    prog                = dcls events;

    events              = {events} event events
                        |;

    line                = {dcl} dcl
                        | {stmt} stmt 
                        | {controlstructure} controlstructure
                        | {action} action;

    val                 = {boolean_literal} boolean_literal
                        | {integer_literal} integer_literal;
                      /*| {rnd} rnd;*/

    lines               = {lines} line lines
                        |;

    printstmt           = {plus} val plus printstmt
                        | {val} val
                        | ;

    dcls                = {dcls} dcl dcls
                        | ;

    dcl                 = {variable_dcl} variable_dcl
                        | {list_dcl} list_dcl;

    variable_dcl        = {variable_dcl} new id assignment_operator val expr;

    list_dcl            = {list_dcl} new id assignment_operator list semi_c;

    list                = {list} brack_l val listvariables brack_r;

    listvariables       = {listvariables} comma val listvariables
                        | {val} val
                        | ;

    controlstructure    = {repeatstructure} repeat repeatstructure
                        | {ifstructure} ifstructure;

    ifstructure         = if par_l bool_operator par_r curly_l lines curly_r;

    elsestructure       = {elsestructure} else  curly_l lines curly_r
                        | ;

    repeatstructure     = {repeatfor} repeatfor
                        | {repeatwhile} repeatwhile
                        | {repeatforeach} repeatforeach;

    repeatfor           = {id} par_l id par_r curly_l lines curly_r
                        | {integer_literal} par_l integer_literal par_r curly_l lines curly_r;

    repeatwhile         = while par_l bool_operator par_r curly_l lines curly_r;

    repeatforeach       = foreach par_l id in list par_r curly_l lines curly_r;

    event               = {startup} startup par_l fig colon id par_r curly_l lines curly_r
/*                      | {key_press} key_press par_l fig colon id comma key colon input_key par_r curly_l lines curly_r*/
                        | {click} click par_l fig colon id par_r curly_l lines curly_r 
                        | {testevent} testevent curly_l lines curly_r;

    condition           = {fig} touch par_l fig colon id par_r
                        | {edge} touch par_l edge par_r;

    type_of_assign      = {incr_assign} incr_assign
                        | {norm_assign} norm_assign;

    incr_assign         = {incr_assign} operator equals val expr;

    norm_assign         = {norm_assign} equals val expr;

    stmt                = {id} id type_of_assign semi_c
                        | {list} list dot add par_l val par_r semi_c;

    expr                = {operator} operator val expr
                        | {dist} dist par_l fig colon val par_r expr
                        | ;

    booleanexpr         = {condition} condition
                        | {bool_operator} [left]:val bool_operator [right]:val booleanexpradd;
                       
    booleanexpradd      = {booleanexpradd} bool_operator booleanexpr
                        | ;

    operator            = {minus} minus val
                        | {plus} plus val
                        | {mult} mult val
                        | {div} div val;

    bool_operator       = {equal} equal
                        | {less_equal} less_equal
                        | {greater_equal} greater_equal
                        | {negate} negate
                        | {and} and
                        | {or} or;

    rnd                 = random par_l [left]:val to [right]:val par_r;

    action              = {actionset} actionset
                        | {actionchange} actionchange
                        | {turn_left} turn_left par_l deg colon val par_r semi_c
                        | {turn_right} turn_right par_l deg colon val par_r semi_c
                        | {walk} walk par_l steps colon val par_r semi_c
                        | {fig} turnto par_l fig colon id par_r semi_c
                        | {deg} turnto par_l deg colon val par_r semi_c
                     /* | {slide} slide par_l sec colon val comma x colon val comma y colon val par_r semi_c */
                        | {wait} wait par_l sec colon val par_r semi_c
                        | {wait_until} wait_until par_l booleanexpr par_r semi_c
                        | {actionsay} actionsay
                        | {actionthink} actionthink
                        | {hide} hide semi_c
                        | {show} show semi_c
                        | {size} size par_l val percentage par_r semi_c
                        | {layer} layer par_l val par_r semi_c
                        | {ask} ask par_l printstmt par_r semi_c;

    actionsay           = {par_r} say par_l printstmt par_r semi_c
                        | {comma} say par_l printstmt comma sec colon val par_r semi_c;

    actionthink         = {comma} think par_l printstmt comma sec colon val par_r semi_c
                        | {par_r} think par_l printstmt par_r semi_c;

    actionset           = {x} set par_l x colon val addition par_r semi_c
                        | {y} set par_l y colon val par_r semi_c;

    addition            = {addition} comma y colon val
                        | ;

    actionchange        = {x} change par_l x colon val addition par_r semi_c
                        | {y} change par_l y colon val par_r semi_c;

    assignment_operator = {equals} equals;

/****************************************************
*   Litterals                                       *
****************************************************/
    boolean_literal = {true} true 
                    | {false} false;

    integer_literal = {decimal} decimal;