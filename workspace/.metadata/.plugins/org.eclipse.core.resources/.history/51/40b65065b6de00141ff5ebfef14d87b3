Package     compiler;

Helpers
	all 			= [0 .. 0xFFFF];
	tab             = 9;
    lf              = 10;
    cr              = 13;
    letter 			= [['a' .. 'z'] + ['A' .. 'Z']];
    digit           = ['0' .. '9'];
    nonzero_digit   = ['1' .. '9'];
    normal			= [[digit + '_'] + letter];   
	dot             = '.';  
	not_cr_lf 		= [all - [cr + lf]];
	eol 			= cr | lf | cr lf;

Tokens

    plus            = '+';
    minus           = '-';
    mult            = '*';
    div             = '/';
    assign          = '=';
    par_l           = '(';
    par_r           = ')';
    curly_l         = '{';
    curly_r         = '}';
    brack_l         = '[';
    brack_r         = ']';
    quote           = '"';
    comma           = ',';
    semi_c          = ';';
    blank           = (' ' | tab | lf | cr)*;

    dot             = '.';
    equal           = '==';
    less_equal      = '<=';
    greater_equal   = '>=';
    negate          = '!=';
    and             = '&&';
    or              = '||';
    less			= '<';
    greater			= '>';
    increment		= '+=';
    decrement		= '-=';
    true            = 'true';
    false           = 'false';
    new             = 'new';
    to				= 'to';
    repeat			= 'repeat';
    while			= 'while';
    random			= 'random';
    if				= 'if';
    else			= 'else';
    foreach			= 'foreach';
    in				= 'in';
    return			= 'return';

	identifier 		= letter (normal)* ;
	
	string_literal 	= '"' not_cr_lf+ '"';	
	double_literal  = digit* dot digit+;  
    integer_literal = digit+;  
    
    
    multiline_comment 	= '/' '*' [all - ['*' + '/']]* '*' '/' ;
    oneline_comment		= '//' [all - [cr + lf]]* eol?;
    
Ignored Tokens
    blank,
    multiline_comment,
    oneline_comment;

Productions
	program					= decls+;

    decls               	= identifier par_l params? par_r curly_l decl* return_value? curly_r;
                        
    decl                	= {variable_declaration} variable_declaration
    						| {function_declaration} function_declaration
    						| {control_statements} control_statments
    						| {assign} expr semi_c;
    					
    variable_declaration	= new identifier equals variable_types variable_tail* semi_c;
    variable_types			= {single} expr
    						| {list} brack_l expr list_var_tail* brack_r;
    variable_tail			= comma new identifier equals variable_types;    											
    list_var_tail 			= comma expr;		
	
	call_params				= expr call_params_tail*;
	call_params_tail		= comma expr;
    
    function_declaration	= new decls;  
    
    return_value			= return expr semi_c;		 
    
    params					= identifier params_tail*;
    params_tail				= comma identifier;
			
    control_statments   	= {while} repeat while par_l expr par_r body
    						| {repeat} repeat opadd par_r body
    						| {foreach} repeat foreach par_l identifier in varname par_r body
    						| {ifstructure} if par_l expr par_r body elsestructure?;
    												  
    elsestructure       	= {else} else body
    						| {ifelse} else if par_l expr par_r body elsestructure?;
    
    body					= curly_l decl* curly_r;
						
	expr					= {equals} opor equals expr
							| {increment} opor increment expr
							| {decrement} opor decrement expr
							| {or} opor;
						
	opor					= {or} opor or opand
							| {and} opand;
	
	opand					= {and} opand and opequate
							| {equate} opequate;
	
	opequate				= {equal} opequate equal opcompare
							| {negate} opequate negate opcompare
							| {compare} opcompare;
						
	opcompare				= {less} opcompare less value
               				| {greater} opcompare greater  value
               				| {less_equal} opcompare less_equal value
               				| {greater_equal} opcompare greater_equal value
               				| {add} opadd;
               				
    opadd					= {plus} opadd plus opmult
    						| {minus} opadd minus opmult
    						| {mult} opmult;
    
    opmult					= {mult} opmult mult opunary
    						| {div} opmult div opunary
    						| {unary} opunary;
    
    opunary					= {minusvalue} minus opunary
    						| {value} value;
	
	value					= {varname} varname function_call?
    						| {literal} literal
    						| {rnd} rnd ;
    
    function_call			= par_l call_params? par_r body?;
    
    varname					= identifier idlist*;
    						
    idlist					= dot identifier;	
    
    compare_token			= {less_equal} less_equal
    						| {less} less 
    						| {greater_equal} greater_equal
    						| {greater} greater;			 

    operator            	= {minus} minus value
                        	| {plus} plus value
                        	| {mult} mult value
                        	| {div} div value;

    bool_operator       	= {equal} equal
                        	| {less_equal} less_equal
                        	| {greater_equal} greater_equal
                        	| {negate} negate
                        	| {and} and
                        	| {or} or
                        	| {less} less
                        	| {greater} greater;
                        	
    rnd                 	= random par_l [left]:value to [right]:value par_r;
    
    literal 				= {boolean_literal} boolean_literal
    						| {integer_literal} integer_literal
    						| {double_literal} double_literal
    						| {string_literal} string_literal;
    
    boolean_literal 		= {true} true 
                    		| {false} false;